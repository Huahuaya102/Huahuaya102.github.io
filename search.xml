<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣--二叉树</title>
      <link href="/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本章是关于二叉树的理论知识以及相关的力扣刷题的笔记。</p><h2 id="2022年3月23日刷题笔记"><a href="#2022年3月23日刷题笔记" class="headerlink" title="2022年3月23日刷题笔记"></a>2022年3月23日刷题笔记</h2><h3 id="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"><a href="#二叉树的前序遍历、中序遍历、后序遍历的统一迭代法" class="headerlink" title="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"></a>二叉树的前序遍历、中序遍历、后序遍历的统一迭代法</h3><p>采用栈实现二叉树的前中后序的迭代遍历<br>迭代过程中有两个操作：（1）处理，将元素放进result数组中；（2）访问，遍历节点<br>为解决访问节点和处理节点不一致的问题，将访问的节点放入栈中，将要处理的节点也放入栈中（用空指针标记）。</p><h4 id="中序遍历：左中右→栈：右中左"><a href="#中序遍历：左中右→栈：右中左" class="headerlink" title="中序遍历：左中右→栈：右中左"></a>中序遍历：左中右→栈：右中左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h4 id="前序遍历：中左右→栈：右左中"><a href="#前序遍历：中左右→栈：右左中" class="headerlink" title="前序遍历：中左右→栈：右左中"></a>前序遍历：中左右→栈：右左中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br></pre></td></tr></table></figure><h4 id="后序遍历：左右中→栈：中右左"><a href="#后序遍历：左右中→栈：中右左" class="headerlink" title="后序遍历：左右中→栈：中右左"></a>后序遍历：左右中→栈：中右左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h3><p>队列先进先出，符合一层一层遍历的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">if(root != nullptr) que.push(root);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int size = que.size();</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for(int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vec.push_back(node -&gt; val);</span><br><span class="line">        if(node -&gt; left) que.push(node -&gt; left); // 左边压入队列</span><br><span class="line">        if(node -&gt; right) que.push(node -&gt; right);  // 右边压入队列</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_back(vec);    // 每一层放入vector</span><br><span class="line">&#125;</span><br><span class="line">// 返回result</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h3><p>先采用二叉树的层序遍历，再reverse一下</p><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p>和层序遍历的逻辑差不多，将每一层的数据存入队列，把每一次队列中的最优一个元素保存至vector</p><h3 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h3><p>和层序遍历的逻辑差不多，将每一层的数据求和，再除以size，得到均值，保存至vector</p><h2 id="2022年3月24日刷题笔记"><a href="#2022年3月24日刷题笔记" class="headerlink" title="2022年3月24日刷题笔记"></a>2022年3月24日刷题笔记</h2><h3 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h3><p>与二叉树的层序遍历方法一样，采用队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Node* node = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vec.push_back(node -&gt; val);</span><br><span class="line">    for(int j = 0; i &lt; node -&gt; children.size(); j++)  // 因为是N叉树，不是左右节点</span><br><span class="line">    &#123;</span><br><span class="line">        que.push(node -&gt; children[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在每个树中找最大值"><a href="#在每个树中找最大值" class="headerlink" title="在每个树中找最大值"></a>在每个树中找最大值</h3><p>二叉树层序遍历的应用，定义一个int用来存放最大值，采用条件语句判断每一层的最大值，将最大值放入队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int maxint = INT_MIN;</span><br><span class="line">maxint = (node -&gt; val) &gt; maxint ? (node -&gt; val) : maxint;</span><br></pre></td></tr></table></figure><h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><p>根据题意：每一层的最后一个节点的next指针指向nullptr<br>         定义两个指针nodePre和node<br>         首先取出每一层的头节点(nodePre)，将头节点的next指针指向该层的第二个节点(node)，再另nodePre指向第二个节点（nodePre &#x3D; nodePre -&gt; next)，以此类推，不断更新，直至尾节点</p><h3 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h3><p>和上一题的区别：不是完美二叉树 但是方法一样</p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>就是二叉树的层序遍历，每遍历一层，将定义的depth加1</p><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>考虑左右节点都为空的时候，即是最低层，输出此时的depth</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
