<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++——面试题</title>
      <link href="/2022/03/26/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/26/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本章是关于c++面试题的相关笔记整理。</p><h3 id="变量的声明和定义有什么区别？"><a href="#变量的声明和定义有什么区别？" class="headerlink" title="变量的声明和定义有什么区别？"></a>变量的声明和定义有什么区别？</h3><p>   （1）变量的定义为变量分配地址和存储空间，变量的声明不分配地址，用于向程序表明变量的类型和名字。<br>   （2）程序中，变量有且仅有一个定义，但是可以在多个地方声明。<br>   （3）定义也是声明，当定义变量时，也声明了它的类型和名字。<br>   （4）extern关键字，修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">extern int va;  // 这是声明，并不是定义，声明va是一个已经定义的外部变量</span><br><span class="line">                // 声明外部变量时可以把变量类型去掉：extern va</span><br><span class="line">&#125;</span><br><span class="line">int va;    // 声明，也是定义，定义va是整型的外部变量</span><br></pre></td></tr></table></figure><p>头文件中的定义与声明：头文件中不可以放变量的定义。一般情况下头文件只放变量的声明，因为头文件要被其他文件包含（即#include），如果把定义放到头文件的话，就不能避免多次定义变量，C++不允许多次定义变量，一个程序中指定变量的定义只有一次，声明可以无数次。<br>三种例外情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int num(10);     // 值在编译时就已知的const变量的定义可以放在头文件中</span><br><span class="line">// 类的定义可以放在头文件中</span><br><span class="line">// inline函数</span><br></pre></td></tr></table></figure><h3 id="简述-ifdef、-else、-endif和-idndef的作用？"><a href="#简述-ifdef、-else、-endif和-idndef的作用？" class="headerlink" title="简述#ifdef、#else、#endif和#idndef的作用？"></a>简述#ifdef、#else、#endif和#idndef的作用？</h3><p>条件编译：部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件。<br>条件编译命令最常见的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">#ifdef 标识符    // 当标识符被定义过（一般用#define命令定义），对程序块1进行编译</span><br><span class="line">    程序块1</span><br><span class="line">#else            // 否则编译程序块2</span><br><span class="line">    程序块2</span><br><span class="line">#endif</span><br><span class="line">// 方式二</span><br><span class="line">#ifndef 标识符     // 与方式一相反</span><br><span class="line">    程序块1</span><br><span class="line">#else</span><br><span class="line">    程序块2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>其中#else部分也可以没有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">    程序块</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>可以通过#ifedf和#ifndef命令测试某个宏是否已被定义，避免重复定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DEBUG    // 如果没有定义DEBUG,再执行下面的定义语句</span><br><span class="line">#define DEBUG</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="写出int、bool、float、指针变量与’零值’比较的if语句？"><a href="#写出int、bool、float、指针变量与’零值’比较的if语句？" class="headerlink" title="写出int、bool、float、指针变量与’零值’比较的if语句？"></a>写出int、bool、float、指针变量与’零值’比较的if语句？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// int与零值比较</span><br><span class="line">if(n == 0)</span><br><span class="line">if(n != 0)</span><br><span class="line"></span><br><span class="line">// bool与零值比较</span><br><span class="line">bool flag;</span><br><span class="line">if(flag)    // 表示flag为真</span><br><span class="line">if(!flag)   // 表示flag为假</span><br><span class="line"></span><br><span class="line">// float与零值比较</span><br><span class="line">const float EPSINON = 0.00001;</span><br><span class="line">if((x &gt;= -EPSINON) &amp;&amp; (x &lt; EPSINON)) // 其中EPSINON是允许的误差（即精度）</span><br><span class="line"></span><br><span class="line">// 指针变量与零值比较</span><br><span class="line">if(p == nullprt)</span><br><span class="line">if(p != nullptr)</span><br></pre></td></tr></table></figure><h3 id="结构体可以直接赋值吗？"><a href="#结构体可以直接赋值吗？" class="headerlink" title="结构体可以直接赋值吗？"></a>结构体可以直接赋值吗？</h3><p>结构体是常用的自定义构造类型，是一种常见的数据打包方法。结构体对象的初始化有多种方式，分为指定初始化、顺序初始化、构造函数初始化。设有结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Mystruct</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">int ages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)指定初始化：采用点号加赋值符号实现或采用冒号实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mystruct mystruct = &#123;.name = &quot;hhhh&quot;, .b = 2&#125;;  // 点号+赋值符号</span><br><span class="line">Mystruct mystruct = &#123;a : &quot;hhhh&quot;, b : 2&#125;;    // 冒号</span><br></pre></td></tr></table></figure><p>(2)顺序初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mystruct mystruct = &#123;&quot;hhhh&quot;, 2&#125;;</span><br></pre></td></tr></table></figure><p>(3)构造函数初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 带构造函数的结构体</span><br><span class="line">strcut Mystruct</span><br><span class="line">&#123;</span><br><span class="line">Mystruct(string name, int ages)&#123;this -&gt; name = name; this -&gt; ages = ages;&#125;;</span><br><span class="line">string name;</span><br><span class="line">int ages;</span><br><span class="line">&#125;</span><br><span class="line">// 初始化</span><br><span class="line">Mystruct mystruct(&quot;hhhh&quot;, 2);</span><br></pre></td></tr></table></figure><p>结构体赋值：<br>变量的赋值和初始化是不一样的，初始化是在变量定义的时候完成的，属于变量定义的一部分，赋值是在变量完成后想改变变量值所采取的操作。结构体变量的赋值是不能采用大括号的方式进行赋值的。依次给每一个结构体成员变量进行赋值。使用已有的结构体变量或另一个结构体变量赋值，即结构体变量之间是可以相互赋值的。</p><h3 id="sizeof和strlen的区别？"><a href="#sizeof和strlen的区别？" class="headerlink" title="sizeof和strlen的区别？"></a>sizeof和strlen的区别？</h3><p>（1）sizeof不是函数，是运算符。strlen是标准库中提供的计算字符串长度的函数；<br>（2）sizeof的参数可以是数据的类型，也可以是变量，而strlen只能是以结尾为’\0’的字符串作为参数；<br>（3）sizeof计算数据所占用的内存大小，以字节为单位，char为一个字节，int通常为4个字节，strlen返回字符串的长度不包括末尾的’\0’；<br>（4）编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来；<br>（5）数组做sizeof的参数不退化（数组名不会退化为指针），传递给strlen就退化为指针了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣--二叉树</title>
      <link href="/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本章是关于二叉树的理论知识以及相关的力扣刷题的笔记。</p><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h2 id="2022年3月23日刷题笔记"><a href="#2022年3月23日刷题笔记" class="headerlink" title="2022年3月23日刷题笔记"></a>2022年3月23日刷题笔记</h2><h3 id="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"><a href="#二叉树的前序遍历、中序遍历、后序遍历的统一迭代法" class="headerlink" title="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"></a>二叉树的前序遍历、中序遍历、后序遍历的统一迭代法</h3><p>采用栈实现二叉树的前中后序的迭代遍历<br>迭代过程中有两个操作：（1）处理，将元素放进result数组中；（2）访问，遍历节点<br>为解决访问节点和处理节点不一致的问题，将访问的节点放入栈中，将要处理的节点也放入栈中（用空指针标记）。</p><h4 id="中序遍历：左中右→栈：右中左"><a href="#中序遍历：左中右→栈：右中左" class="headerlink" title="中序遍历：左中右→栈：右中左"></a>中序遍历：左中右→栈：右中左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h4 id="前序遍历：中左右→栈：右左中"><a href="#前序遍历：中左右→栈：右左中" class="headerlink" title="前序遍历：中左右→栈：右左中"></a>前序遍历：中左右→栈：右左中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br></pre></td></tr></table></figure><h4 id="后序遍历：左右中→栈：中右左"><a href="#后序遍历：左右中→栈：中右左" class="headerlink" title="后序遍历：左右中→栈：中右左"></a>后序遍历：左右中→栈：中右左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h3><p>队列先进先出，符合一层一层遍历的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">if(root != nullptr) que.push(root);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int size = que.size();</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for(int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vec.push_back(node -&gt; val);</span><br><span class="line">        if(node -&gt; left) que.push(node -&gt; left); // 左边压入队列</span><br><span class="line">        if(node -&gt; right) que.push(node -&gt; right);  // 右边压入队列</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_back(vec);    // 每一层放入vector</span><br><span class="line">&#125;</span><br><span class="line">// 返回result</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h3><p>先采用二叉树的层序遍历，再reverse一下</p><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p>和层序遍历的逻辑差不多，将每一层的数据存入队列，把每一次队列中的最优一个元素保存至vector</p><h3 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h3><p>和层序遍历的逻辑差不多，将每一层的数据求和，再除以size，得到均值，保存至vector</p><h2 id="2022年3月24日刷题笔记"><a href="#2022年3月24日刷题笔记" class="headerlink" title="2022年3月24日刷题笔记"></a>2022年3月24日刷题笔记</h2><h3 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h3><p>与二叉树的层序遍历方法一样，采用队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Node* node = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vec.push_back(node -&gt; val);</span><br><span class="line">    for(int j = 0; i &lt; node -&gt; children.size(); j++)  // 因为是N叉树，不是左右节点</span><br><span class="line">    &#123;</span><br><span class="line">        que.push(node -&gt; children[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在每个树中找最大值"><a href="#在每个树中找最大值" class="headerlink" title="在每个树中找最大值"></a>在每个树中找最大值</h3><p>二叉树层序遍历的应用，定义一个int用来存放最大值，采用条件语句判断每一层的最大值，将最大值放入队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int maxint = INT_MIN;</span><br><span class="line">maxint = (node -&gt; val) &gt; maxint ? (node -&gt; val) : maxint;</span><br></pre></td></tr></table></figure><h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><p>根据题意：每一层的最后一个节点的next指针指向nullptr<br>         定义两个指针nodePre和node<br>         首先取出每一层的头节点(nodePre)，将头节点的next指针指向该层的第二个节点(node)，再另nodePre指向第二个节点（nodePre &#x3D; nodePre -&gt; next)，以此类推，不断更新，直至尾节点</p><h3 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h3><p>和上一题的区别：不是完美二叉树 但是方法一样</p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>就是二叉树的层序遍历，每遍历一层，将定义的depth加1</p><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>考虑左右节点都为空的时候，即是最低层，输出此时的depth</p><h2 id="2022年3月25日刷题笔记"><a href="#2022年3月25日刷题笔记" class="headerlink" title="2022年3月25日刷题笔记"></a>2022年3月25日刷题笔记</h2><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>将每个节点的左右分支进行翻转，达到整体翻转的目的。<br>采用层序遍历的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* node = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    swap(node -&gt; left, node -&gt; right);</span><br><span class="line">    if(node -&gt; left) que.push(node -&gt; left);</span><br><span class="line">    if(node -&gt; right) que.push(node -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树：检查是否是轴对称"><a href="#对称二叉树：检查是否是轴对称" class="headerlink" title="对称二叉树：检查是否是轴对称"></a>对称二叉树：检查是否是轴对称</h3><p>需要比较的并不是左右节点，需要比较的是根节点的左分支和右分支是不是相互翻转的→左分支的遍历顺序是左右中，右分支的遍历顺序是右左中<br>递归：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先排除左右分支是空节点的情况</span><br><span class="line">if(left == nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">else if(left == nullprt &amp;&amp; right != nullptr) return false;</span><br><span class="line">else if(left != nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">// 然后排除左右分支节点不相同的情况</span><br><span class="line">else if(left -&gt; val != right -&gt; val) return false;</span><br><span class="line">// 左右分支节点都不为空，且数值相同</span><br><span class="line">bool first = compare(left -&gt; left, right -&gt; right);</span><br><span class="line">bool second = compare(left -&gt; right, right -&gt; left);</span><br><span class="line">return first &amp;&amp; second;</span><br></pre></td></tr></table></figure><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>需要比较两个树，与对称二叉树需要比较的一样都是树，不同点在于该题是：左分支与左分支比较，右分支与右分支比较。</p><h3 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h3><p>两个树相等或该树的左树是子树或该树的右树是子树。</p><h2 id="2022年3月26日刷题笔记"><a href="#2022年3月26日刷题笔记" class="headerlink" title="2022年3月26日刷题笔记"></a>2022年3月26日刷题笔记</h2><h3 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h3><p>题目描述：给定一个N叉树，找到最大深度。最大深度是指从根节点到最远叶子节点的最长路路径上的节点总数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 迭代法，层序遍历的方式，采用队列</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;    </span><br><span class="line">        if(root != nullptr) que.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();     </span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                for(int j = 0; j &lt; node -&gt; children.size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(node -&gt; children[j]) que.push(node -&gt; children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        retutn depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p>题目描述：给你一棵完全二叉树的根节点root，求出该树的节点个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 采用层序遍历的方式</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if(root != nullptr) que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                count++;</span><br><span class="line">                if(node -&gt; left) que.push(node -&gt; left);</span><br><span class="line">                if(node -&gt; right) que.push(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
