<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++——面试题</title>
      <link href="/2022/03/26/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/26/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本章是关于c++面试题的相关笔记整理。</p><h3 id="变量的声明和定义有什么区别？"><a href="#变量的声明和定义有什么区别？" class="headerlink" title="变量的声明和定义有什么区别？"></a>变量的声明和定义有什么区别？</h3><p>   （1）变量的定义为变量分配地址和存储空间，变量的声明不分配地址，用于向程序表明变量的类型和名字。<br>   （2）程序中，变量有且仅有一个定义，但是可以在多个地方声明。<br>   （3）定义也是声明，当定义变量时，也声明了它的类型和名字。<br>   （4）extern关键字，修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">extern int va;  // 这是声明，并不是定义，声明va是一个已经定义的外部变量</span><br><span class="line">                // 声明外部变量时可以把变量类型去掉：extern va</span><br><span class="line">&#125;</span><br><span class="line">int va;    // 声明，也是定义，定义va是整型的外部变量</span><br></pre></td></tr></table></figure><p>头文件中的定义与声明：头文件中不可以放变量的定义。一般情况下头文件只放变量的声明，因为头文件要被其他文件包含（即#include），如果把定义放到头文件的话，就不能避免多次定义变量，C++不允许多次定义变量，一个程序中指定变量的定义只有一次，声明可以无数次。<br>三种例外情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int num(10);     // 值在编译时就已知的const变量的定义可以放在头文件中</span><br><span class="line">// 类的定义可以放在头文件中</span><br><span class="line">// inline函数</span><br></pre></td></tr></table></figure><h3 id="简述-ifdef、-else、-endif和-idndef的作用？"><a href="#简述-ifdef、-else、-endif和-idndef的作用？" class="headerlink" title="简述#ifdef、#else、#endif和#idndef的作用？"></a>简述#ifdef、#else、#endif和#idndef的作用？</h3><p>条件编译：部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件。<br>条件编译命令最常见的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方式一</span><br><span class="line">#ifdef 标识符    // 当标识符被定义过（一般用#define命令定义），对程序块1进行编译</span><br><span class="line">    程序块1</span><br><span class="line">#else            // 否则编译程序块2</span><br><span class="line">    程序块2</span><br><span class="line">#endif</span><br><span class="line">// 方式二</span><br><span class="line">#ifndef 标识符     // 与方式一相反</span><br><span class="line">    程序块1</span><br><span class="line">#else</span><br><span class="line">    程序块2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>其中#else部分也可以没有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">    程序块</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>可以通过#ifedf和#ifndef命令测试某个宏是否已被定义，避免重复定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef DEBUG    // 如果没有定义DEBUG,再执行下面的定义语句</span><br><span class="line">#define DEBUG</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="写出int、bool、float、指针变量与’零值’比较的if语句？"><a href="#写出int、bool、float、指针变量与’零值’比较的if语句？" class="headerlink" title="写出int、bool、float、指针变量与’零值’比较的if语句？"></a>写出int、bool、float、指针变量与’零值’比较的if语句？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// int与零值比较</span><br><span class="line">if(n == 0)</span><br><span class="line">if(n != 0)</span><br><span class="line"></span><br><span class="line">// bool与零值比较</span><br><span class="line">bool flag;</span><br><span class="line">if(flag)    // 表示flag为真</span><br><span class="line">if(!flag)   // 表示flag为假</span><br><span class="line"></span><br><span class="line">// float与零值比较</span><br><span class="line">const float EPSINON = 0.00001;</span><br><span class="line">if((x &gt;= -EPSINON) &amp;&amp; (x &lt; EPSINON)) // 其中EPSINON是允许的误差（即精度）</span><br><span class="line"></span><br><span class="line">// 指针变量与零值比较</span><br><span class="line">if(p == nullprt)</span><br><span class="line">if(p != nullptr)</span><br></pre></td></tr></table></figure><h3 id="结构体可以直接赋值吗？"><a href="#结构体可以直接赋值吗？" class="headerlink" title="结构体可以直接赋值吗？"></a>结构体可以直接赋值吗？</h3><p>结构体是常用的自定义构造类型，是一种常见的数据打包方法。结构体对象的初始化有多种方式，分为指定初始化、顺序初始化、构造函数初始化。设有结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Mystruct</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">int ages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)指定初始化：采用点号加赋值符号实现或采用冒号实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mystruct mystruct = &#123;.name = &quot;hhhh&quot;, .b = 2&#125;;  // 点号+赋值符号</span><br><span class="line">Mystruct mystruct = &#123;a : &quot;hhhh&quot;, b : 2&#125;;    // 冒号</span><br></pre></td></tr></table></figure><p>(2)顺序初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mystruct mystruct = &#123;&quot;hhhh&quot;, 2&#125;;</span><br></pre></td></tr></table></figure><p>(3)构造函数初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 带构造函数的结构体</span><br><span class="line">strcut Mystruct</span><br><span class="line">&#123;</span><br><span class="line">Mystruct(string name, int ages)&#123;this -&gt; name = name; this -&gt; ages = ages;&#125;;</span><br><span class="line">string name;</span><br><span class="line">int ages;</span><br><span class="line">&#125;</span><br><span class="line">// 初始化</span><br><span class="line">Mystruct mystruct(&quot;hhhh&quot;, 2);</span><br></pre></td></tr></table></figure><p>结构体赋值：<br>变量的赋值和初始化是不一样的，初始化是在变量定义的时候完成的，属于变量定义的一部分，赋值是在变量完成后想改变变量值所采取的操作。结构体变量的赋值是不能采用大括号的方式进行赋值的。依次给每一个结构体成员变量进行赋值。使用已有的结构体变量或另一个结构体变量赋值，即结构体变量之间是可以相互赋值的。</p><h3 id="sizeof和strlen的区别？"><a href="#sizeof和strlen的区别？" class="headerlink" title="sizeof和strlen的区别？"></a>sizeof和strlen的区别？</h3><p>（1）sizeof不是函数，是运算符。strlen是标准库中提供的计算字符串长度的函数；<br>（2）sizeof的参数可以是数据的类型，也可以是变量，而strlen只能是以结尾为’\0’的字符串作为参数；<br>（3）sizeof计算数据所占用的内存大小，以字节为单位，char为一个字节，int通常为4个字节，strlen返回字符串的长度不包括末尾的’\0’；<br>（4）编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来；<br>（5）数组做sizeof的参数不退化（数组名不会退化为指针），传递给strlen就退化为指针了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣--二叉树</title>
      <link href="/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本章是关于二叉树的理论知识以及相关的力扣刷题的笔记。</p><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是n(n≥0)个结点的有限集。n&#x3D;0时称为空树。在任意一棵非空树上：<br>（1）有且仅有一个特定的称为根（Root）的结点；<br>（2）当n≥1时，其余结点可以分为m(m&gt;0)个互不相交的有限集，其中每一个集合本身有时一棵树，并且称为根的子树（subTree)。<br>对树的定义还需要强调两点：<br>（1）n&gt;0时根结点是唯一的，不可能存在多个根结点；<br>（2）m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</p><h4 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree)。度为0的结点称为叶结点或终端结点；度不为0的结点称为非终端结点或分支结点，分支结点也称为内部节点。树的度是树内各结点的度的最大值。</p><h4 id="结点间的关系"><a href="#结点间的关系" class="headerlink" title="结点间的关系"></a>结点间的关系</h4><p>结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙。</p><h4 id="树的其它相关概念"><a href="#树的其它相关概念" class="headerlink" title="树的其它相关概念"></a>树的其它相关概念</h4><p>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为深度或高度。<br>如果将树中结点的各子树看成是从左至右有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><h4 id="线性表和树的对比"><a href="#线性表和树的对比" class="headerlink" title="线性表和树的对比"></a>线性表和树的对比</h4><p>线性结构：第一个数据元素无前驱；最后一个数据元素无后继；中间元素一个前驱，一个后继。<br>树结构：根节点，无双亲，唯一；叶结点，无孩子，可以多个；中间结点，一个双亲，多个孩子。</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是n(n≥0)个结点的有限几何 ，该集合或者为空集（称为空二叉树），或者由一个额根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</p><h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>(1)每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。<br>(2)左子树和右子树是有顺序的，次序不能任意颠倒。<br>(3)即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。<br>二叉树具有五种形态：<br>(1)空二叉树；(2)只有一个根节点；(3)根节点只有左子树；(4)根节点只有右子树；(5)根节点既有左子树又有右子树。</p><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><p>(1)斜树：所有结点都只有左子树的二叉树称为左斜树。所有结点都只有右子树的二叉树称为右斜树。这两者统称为斜树。<br>(2)满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。满二叉树的特点：①叶子只能出现在最下一层；②非叶子结点的度一定是2；③在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。<br>(3)完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1≤i≤n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。完全二叉树的特点：①叶子结点只能出现在最下两层；②最下层的叶子一定集中在左部连续位置；③倒数二层，如有叶子结点，一定都在右部连续位置；④如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况；⑤同样节点数的二叉树，完全二叉树的深度最小。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>(1)在二叉树的第1层上至多有2<sup>i-1</sup>个结点(i ≥ 1)；<br>(2)深度为k的二叉树至多有2<sup>k</sup>-1个结点(k ≥ 1)；<br>(3)对任何一个二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>&#x3D;n<sub>2</sub>+1；<br>(4)具有n个结点的完全二叉树的深度为[log<sub>2</sub>n]+1([X]表示不大于X的最大整数)；<br>(5)如果对一棵有n个结点的完全二叉树(其深度为[log<sub>2</sub>n]+1)的结点按层序编号(从第1层到第[log<sub>2</sub>n]+1层，每层从左到右)，对任一结点i(1 ≤ i ≤ n)有：①如果i&#x3D;1,则结点i是二叉树的根，无双亲；如果i&gt;1，则双亲是结点[i&#x2F;2]；②如果2i&gt;n，则结点i无左孩子(结点i为叶子节点)，否则其左孩子就是结点2i；③如果2i+1&gt;n，则结点无右孩子；否则其右孩子就是2i+1。</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树的顺序存储结构"><a href="#二叉树的顺序存储结构" class="headerlink" title="二叉树的顺序存储结构"></a>二叉树的顺序存储结构</h4><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。顺序存储的结构一般只用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，将这样的链表称为二叉链表。二叉链表的结点结构定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode</span><br><span class="line">&#123;</span><br><span class="line">    TElemType data;  // 结点数据</span><br><span class="line">    struct BiTNode *lchild, *rchild;  // 左右孩子指针</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点都被访问依次且仅被访问一次。</p><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><p>规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归的方法</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void traversal(TreeNode* curnode, vector&lt;int&gt;&amp; re) // vector用于存放结点的数值</span><br><span class="line">    &#123;</span><br><span class="line">        if(curnode == nullptr) return;      // 当前遍历的结点为空，本轮递归结束</span><br><span class="line">        re.push_back(curnode -&gt; val);       // 先取根节点的值</span><br><span class="line">        traversal(curnode -&gt; left, re);     // 左</span><br><span class="line">        traversal(curnode -&gt; right, re);    // 右</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><p>规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归法</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void traversal(TreeNode* curnode, vector&lt;int&gt;&amp; re)</span><br><span class="line">    &#123;</span><br><span class="line">        if(curnode == nullptr) return;</span><br><span class="line">        traversal(curnode -&gt; left, re);   // 左</span><br><span class="line">        re.push(curnode -&gt; val);          // 根</span><br><span class="line">        traversal(curenode -&gt; right, re); // 右</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        return result;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h4><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归法</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void traversal(TreeNode* curnode, vector&lt;int&gt;&amp; re)</span><br><span class="line">    &#123;</span><br><span class="line">        if(curnode == nullptr) return;</span><br><span class="line">        traversal(curnode -&gt; left, re);   // 左</span><br><span class="line">        traversal(curnode -&gt; right, re);  // 右</span><br><span class="line">        re.push_back(curnode -&gt; val);     // 根</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 采用队列的方式实现二叉树的层序遍历</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; quetree;    </span><br><span class="line">        if(root != nullptr) quetree.push(root);</span><br><span class="line">        while(!quetree.empty())    // 队列不为空</span><br><span class="line">        &#123;</span><br><span class="line">            int size = quetree.size();</span><br><span class="line">            vector&lt;int&gt; re;     // 存放每一层的结果</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Treenode* node = quetree.front();</span><br><span class="line">                quetree.pop();</span><br><span class="line">                re.push_back(node -&gt; val);</span><br><span class="line">                if(node -&gt; left) quetree.push(node -&gt; left);</span><br><span class="line">                if(node -&gt; right) quetree.push(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(re);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2022年3月23日刷题笔记"><a href="#2022年3月23日刷题笔记" class="headerlink" title="2022年3月23日刷题笔记"></a>2022年3月23日刷题笔记</h2><h3 id="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"><a href="#二叉树的前序遍历、中序遍历、后序遍历的统一迭代法" class="headerlink" title="二叉树的前序遍历、中序遍历、后序遍历的统一迭代法"></a>二叉树的前序遍历、中序遍历、后序遍历的统一迭代法</h3><p>采用栈实现二叉树的前中后序的迭代遍历<br>迭代过程中有两个操作：（1）处理，将元素放进result数组中；（2）访问，遍历节点<br>为解决访问节点和处理节点不一致的问题，将访问的节点放入栈中，将要处理的节点也放入栈中（用空指针标记）。</p><h4 id="中序遍历：左中右→栈：右中左"><a href="#中序遍历：左中右→栈：右中左" class="headerlink" title="中序遍历：左中右→栈：右中左"></a>中序遍历：左中右→栈：右中左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h4 id="前序遍历：中左右→栈：右左中"><a href="#前序遍历：中左右→栈：右左中" class="headerlink" title="前序遍历：中左右→栈：右左中"></a>前序遍历：中左右→栈：右左中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br></pre></td></tr></table></figure><h4 id="后序遍历：左右中→栈：中右左"><a href="#后序遍历：左右中→栈：中右左" class="headerlink" title="后序遍历：左右中→栈：中右左"></a>后序遍历：左右中→栈：中右左</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.push(node);</span><br><span class="line">stack.push(nullptr);</span><br><span class="line">if(node -&gt; right) stack.push(node -&gt; right);</span><br><span class="line">if(node -&gt; left) stack.push(node -&gt; left); </span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h3><p>队列先进先出，符合一层一层遍历的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">if(root != nullptr) que.push(root);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int size = que.size();</span><br><span class="line">    vector&lt;int&gt; vec;</span><br><span class="line">    for(int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vec.push_back(node -&gt; val);</span><br><span class="line">        if(node -&gt; left) que.push(node -&gt; left); // 左边压入队列</span><br><span class="line">        if(node -&gt; right) que.push(node -&gt; right);  // 右边压入队列</span><br><span class="line">    &#125;</span><br><span class="line">    result.push_back(vec);    // 每一层放入vector</span><br><span class="line">&#125;</span><br><span class="line">// 返回result</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h3><p>先采用二叉树的层序遍历，再reverse一下</p><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p>和层序遍历的逻辑差不多，将每一层的数据存入队列，把每一次队列中的最优一个元素保存至vector</p><h3 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h3><p>和层序遍历的逻辑差不多，将每一层的数据求和，再除以size，得到均值，保存至vector</p><h2 id="2022年3月24日刷题笔记"><a href="#2022年3月24日刷题笔记" class="headerlink" title="2022年3月24日刷题笔记"></a>2022年3月24日刷题笔记</h2><h3 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h3><p>与二叉树的层序遍历方法一样，采用队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Node* node = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vec.push_back(node -&gt; val);</span><br><span class="line">    for(int j = 0; i &lt; node -&gt; children.size(); j++)  // 因为是N叉树，不是左右节点</span><br><span class="line">    &#123;</span><br><span class="line">        que.push(node -&gt; children[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在每个树中找最大值"><a href="#在每个树中找最大值" class="headerlink" title="在每个树中找最大值"></a>在每个树中找最大值</h3><p>二叉树层序遍历的应用，定义一个int用来存放最大值，采用条件语句判断每一层的最大值，将最大值放入队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int maxint = INT_MIN;</span><br><span class="line">maxint = (node -&gt; val) &gt; maxint ? (node -&gt; val) : maxint;</span><br></pre></td></tr></table></figure><h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><p>根据题意：每一层的最后一个节点的next指针指向nullptr<br>         定义两个指针nodePre和node<br>         首先取出每一层的头节点(nodePre)，将头节点的next指针指向该层的第二个节点(node)，再另nodePre指向第二个节点（nodePre &#x3D; nodePre -&gt; next)，以此类推，不断更新，直至尾节点</p><h3 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h3><p>和上一题的区别：不是完美二叉树 但是方法一样</p><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>就是二叉树的层序遍历，每遍历一层，将定义的depth加1</p><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>考虑左右节点都为空的时候，即是最低层，输出此时的depth</p><h2 id="2022年3月25日刷题笔记"><a href="#2022年3月25日刷题笔记" class="headerlink" title="2022年3月25日刷题笔记"></a>2022年3月25日刷题笔记</h2><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>将每个节点的左右分支进行翻转，达到整体翻转的目的。<br>采用层序遍历的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* node = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    swap(node -&gt; left, node -&gt; right);</span><br><span class="line">    if(node -&gt; left) que.push(node -&gt; left);</span><br><span class="line">    if(node -&gt; right) que.push(node -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树：检查是否是轴对称"><a href="#对称二叉树：检查是否是轴对称" class="headerlink" title="对称二叉树：检查是否是轴对称"></a>对称二叉树：检查是否是轴对称</h3><p>需要比较的并不是左右节点，需要比较的是根节点的左分支和右分支是不是相互翻转的→左分支的遍历顺序是左右中，右分支的遍历顺序是右左中<br>递归：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 首先排除左右分支是空节点的情况</span><br><span class="line">if(left == nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">else if(left == nullprt &amp;&amp; right != nullptr) return false;</span><br><span class="line">else if(left != nullptr &amp;&amp; right == nullptr) return false;</span><br><span class="line">// 然后排除左右分支节点不相同的情况</span><br><span class="line">else if(left -&gt; val != right -&gt; val) return false;</span><br><span class="line">// 左右分支节点都不为空，且数值相同</span><br><span class="line">bool first = compare(left -&gt; left, right -&gt; right);</span><br><span class="line">bool second = compare(left -&gt; right, right -&gt; left);</span><br><span class="line">return first &amp;&amp; second;</span><br></pre></td></tr></table></figure><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><p>需要比较两个树，与对称二叉树需要比较的一样都是树，不同点在于该题是：左分支与左分支比较，右分支与右分支比较。</p><h3 id="另一棵树的子树"><a href="#另一棵树的子树" class="headerlink" title="另一棵树的子树"></a>另一棵树的子树</h3><p>两个树相等或该树的左树是子树或该树的右树是子树。</p><h2 id="2022年3月26日刷题笔记"><a href="#2022年3月26日刷题笔记" class="headerlink" title="2022年3月26日刷题笔记"></a>2022年3月26日刷题笔记</h2><h3 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h3><p>题目描述：给定一个N叉树，找到最大深度。最大深度是指从根节点到最远叶子节点的最长路路径上的节点总数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 迭代法，层序遍历的方式，采用队列</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(Node* root)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;Node*&gt; que;    </span><br><span class="line">        if(root != nullptr) que.push(root);</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();     </span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                for(int j = 0; j &lt; node -&gt; children.size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(node -&gt; children[j]) que.push(node -&gt; children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        retutn depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p>题目描述：给你一棵完全二叉树的根节点root，求出该树的节点个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 采用层序遍历的方式</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int countNodes(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        if(root != nullptr) que.push(root);</span><br><span class="line">        while(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                count++;</span><br><span class="line">                if(node -&gt; left) que.push(node -&gt; left);</span><br><span class="line">                if(node -&gt; right) que.push(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2022年3月27日刷题笔记"><a href="#2022年3月27日刷题笔记" class="headerlink" title="2022年3月27日刷题笔记"></a>2022年3月27日刷题笔记</h2><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个结点的左右子树的高度差的绝对值不超过1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 递归法</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int getHeight(TreeNode* node)  // 返回以该结点为根结点的二叉树的高度，如果不是平衡二叉树，没必要输出高度，直接返回-1</span><br><span class="line">    &#123;</span><br><span class="line">        if(node == nullptr) return 0;    // 以当前结点为根结点的树高度为0</span><br><span class="line">        int leftheight = getHeight(node -&gt; left);  </span><br><span class="line">        int rightheight = getHeight(node -&gt; right);</span><br><span class="line"></span><br><span class="line">        int result;</span><br><span class="line">        if(abs(leftheight - rightheight) &gt; 1)  // 高度差大于1</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;    // 不是平衡二叉树，返回-1</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result = 1 + max(leftheight, rightheight);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        if(leftheight == -1) return -1;</span><br><span class="line">        if(rightheight == -1) return -1;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        return getHeight(root) == -1 ? false : true;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><p>题目描述：给你一个二叉树的根结点root，按任意顺序，返回所有从根结点到叶子结点（没有子结点的结点）的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 递归的方式，采用前序遍历：中左右，便于路径的统计</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void getPath(TreeNode* curnode, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; re)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(curnode -&gt; val);  // 记录根结点的值</span><br><span class="line">        if(curnode -&gt; left == nullptr &amp;&amp; curnode -&gt; right == nullptr)  // 当前结点是叶子结点</span><br><span class="line">        &#123;</span><br><span class="line">            string spath;   // 存储单个路径</span><br><span class="line">            int len = path.size() - 1;</span><br><span class="line">            for(int i = 0; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                spath += to_string(path[i]);</span><br><span class="line">                spath += &quot;-&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            spath += to_string(path[len]);</span><br><span class="line">            re.push_back(spath);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(curnode -&gt; left) </span><br><span class="line">        &#123;</span><br><span class="line">            getPath(curnode -&gt; left, path, re);</span><br><span class="line">            path.pop_back();   // 删除结点，便于后序加入新的结点</span><br><span class="line">        &#125;</span><br><span class="line">        if(curnode -&gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            getPath(curnode -&gt; right, path, re);</span><br><span class="line">            path.pop_back();   // 删除结点，便于后序加入新的结点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; binaryTreePaths(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        if(root == nullptr) return result;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        getPath(root, path, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><p>题目描述：给定二叉树的根节点root，返回所有左叶子之和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 遍历一遍二叉树，找到左叶子结点，累加它们的值</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int sum = 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
